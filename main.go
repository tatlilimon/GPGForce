package main

import (
	"crypto"
	"encoding/hex"
	"fmt"
	"math"
	"os"
	"regexp"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/joho/godotenv"
	"golang.org/x/crypto/openpgp"
	"golang.org/x/crypto/openpgp/packet"
)

// KeyResult represents a generated GPG key and its fingerprint
type KeyResult struct {
	entity      *openpgp.Entity
	fingerprint string
}

// generateKey creates a new GPG key pair with given name and email
func generateKey(name, email string) (*openpgp.Entity, error) {
	if name == "" || email == "" {
		return nil, fmt.Errorf("name and email are required")
	}

	comment := os.Getenv("COMMENT")
	if comment == "" {
		comment = "Generated by GPGForce 1.0"
	}

	config := packet.Config{
		RSABits: 2048, // 2048-bit RSA keys
		Time:    time.Now,
	}

	entity, err := openpgp.NewEntity(name, comment, email, &config)
	if err != nil {
		return nil, err
	}

	return entity, nil
}

// saveKeys stores both private and public keys to files with given prefix
func saveKeys(entity *openpgp.Entity, prefix string) error {

	// Create keys directory if it doesn't exist
	err := os.MkdirAll("keys", 0755)
	if err != nil {
		return err
	}

	// Save private key with encryption
	privateKeyFile, err := os.Create(fmt.Sprintf("keys/%s_private.gpg", prefix))
	if err != nil {
		return err
	}
	defer privateKeyFile.Close()

	// Configure encryption parameters
	config := &packet.Config{
		DefaultHash:            crypto.SHA256,          // SHA256 Hashing
		DefaultCipher:          packet.CipherAES256,    // AES256 Symmetric Encryption
		DefaultCompressionAlgo: packet.CompressionZLIB, // ZLIB compression
		S2KCount:               65011712,               // Increase iteration count for better security
	}

	// Serialize the private key directly with the config
	err = entity.SerializePrivate(privateKeyFile, config)
	if err != nil {
		return fmt.Errorf("failed to serialize private key: %v", err)
	}

	// Save public key
	publicKeyFile, err := os.Create(fmt.Sprintf("keys/%s_public.gpg", prefix))
	if err != nil {
		return err
	}
	defer publicKeyFile.Close()

	return entity.Serialize(publicKeyFile)
}

// searchForKey continuously generates keys until finding one with desired prefix
func searchForKey(desiredPrefix string, attempts *uint64, resultChan chan<- KeyResult, stopChan chan struct{}, wg *sync.WaitGroup) {
	defer wg.Done()
	name := os.Getenv("NAME")
	email := os.Getenv("EMAIL")

	// Validate environment variables
	if name == "" || email == "" {
		fmt.Printf("[ERROR] NAME and EMAIL environment variables must be set\n")
		return
	}

	for {
		select {
		case <-stopChan:
			return
		default:
			atomic.AddUint64(attempts, 1)

			entity, err := generateKey(name, email)
			if err != nil {
				fmt.Printf("[ERROR] Key generation failed: %v\n", err)
				return
			}

			fingerprint := strings.ToUpper(hex.EncodeToString(entity.PrimaryKey.Fingerprint[:]))
			if strings.HasPrefix(fingerprint, desiredPrefix) {
				select {
				case resultChan <- KeyResult{entity: entity, fingerprint: fingerprint}:
					close(stopChan) // Signal other workers to stop
					return
				case <-stopChan:
					return
				}
			}
		}
	}
}

func main() {
	// Validate arguments
	if len(os.Args) != 2 {
		fmt.Println("Usage: gpgforce <desired-prefix>")
		os.Exit(1)
	}

	// Get desired prefix on 1. argument
	desiredPrefix := strings.ToUpper(os.Args[1])

	// Prefix can't be longer than 40 character
	if len(desiredPrefix) > 40 {
		fmt.Println("[ERROR] The prefix length cannot be longer than 40 characters (full fingerprint length)")
		os.Exit(1)
	}
	// Prefix must be hexadecimal format
	if !regexp.MustCompile(`^[0-9A-F]+$`).MatchString(desiredPrefix) {
		fmt.Println("[ERROR] The prefix must contain only hexadecimal characters (0-9 or A-F)")
		os.Exit(1)
	}
	// Load .env file at startup
	if err := godotenv.Load(); err != nil {
		fmt.Printf("[ERROR] Error loading .env file: %v\n", err)
	}

	// Validate required environment variables are set
	name := os.Getenv("NAME")
	email := os.Getenv("EMAIL")
	if name == "" || email == "" {
		fmt.Println("[ERROR] Required environment variables NAME and EMAIL are not set. Please ensure these are set in your .env file")
		os.Exit(1)
	}

	fmt.Printf("\n[START] Searching for GPG key with fingerprint starting with: %s\n", desiredPrefix)
	fmt.Printf("  [INFO] Disered Prefix probability: 1/%.0f\n\n", math.Pow(16, float64(len(desiredPrefix))))

	startTime := time.Now()
	var attempts uint64
	resultChan := make(chan KeyResult, 1) // Buffered channel to prevent blocking
	stopChan := make(chan struct{})
	var wg sync.WaitGroup

	// Start workers equal to number of CPU cores
	for i := 0; i < runtime.NumCPU(); i++ {
		wg.Add(1)
		go searchForKey(desiredPrefix, &attempts, resultChan, stopChan, &wg)
	}

	// Progress reporting goroutine
	ticker := time.NewTicker(100 * time.Millisecond)
	done := make(chan struct{})
	go func() {
		defer ticker.Stop()
		for {
			select {
			case <-done:
				return
			case <-ticker.C:
				currentAttempts := atomic.LoadUint64(&attempts)
				elapsed := time.Since(startTime).Seconds()
				rate := float64(currentAttempts) / elapsed
				fmt.Printf("\r[CURRENT] Generated %d keys (%.2f keys/sec)...", currentAttempts, rate)
			}
		}
	}()

	// Wait for either a result or all workers to finish
	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// Wait for result
	result, ok := <-resultChan
	close(done) // Stop progress reporting

	if !ok {
		fmt.Printf("\n[ERROR] No matching key found - all workers finished\n")
		os.Exit(1)
	}

	fmt.Printf("\n\n[OK] Found matching key!\n")
	fmt.Printf("   [LOG] Total attempts: %d\n", atomic.LoadUint64(&attempts))
	fmt.Printf("   [LOG] Key Fingerprint: %s\n", result.fingerprint)

	err := saveKeys(result.entity, desiredPrefix)
	if err != nil {
		fmt.Printf("[ERROR] Error saving keys: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("[OK] Keys saved successfully:\n")
	fmt.Printf("   [LOG] keys/%s_private.gpg \n", desiredPrefix)
	fmt.Printf("   [LOG] keys/%s_public.gpg\n", desiredPrefix)

	elapsedTime := time.Since(startTime)
	fmt.Printf("\n[END] Total time: %v\n\n", elapsedTime)
}
